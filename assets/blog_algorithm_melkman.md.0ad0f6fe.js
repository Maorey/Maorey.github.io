import{o as e,c as a,b as l}from"./app.259d0bf0.js";const r='{"title":"最小凸包","description":"","frontmatter":{"title":"最小凸包","index":2},"headers":[{"level":2,"title":"问题描述","slug":"问题描述"},{"level":3,"title":"凸多边形定义","slug":"凸多边形定义"},{"level":3,"title":"多边形相交定义","slug":"多边形相交定义"},{"level":2,"title":"演示","slug":"演示"},{"level":2,"title":"方法介绍","slug":"方法介绍"},{"level":3,"title":"穷举法 (O(n))","slug":"穷举法-o-n3"},{"level":3,"title":"分治法 (快包 O(n㏒n))","slug":"分治法-快包-o-n㏒n"},{"level":3,"title":"Jarvis 步进法 (O(nH))","slug":"jarvis-步进法-o-nh"},{"level":3,"title":"Graham 扫描法 (O(n㏒n))","slug":"graham-扫描法-o-n㏒n"},{"level":3,"title":"Melkman 算法 (O(n))","slug":"melkman-算法-o-n"},{"level":2,"title":"Melkman 算法实现","slug":"melkman-算法实现"},{"level":2,"title":"升维","slug":"升维"}],"relativePath":"blog/algorithm/melkman.md","lastUpdated":1620241308085}',h={},n=l('<h2 id="问题描述"><a class="header-anchor" href="#问题描述" aria-hidden="true">#</a> 问题描述</h2><p>平面上任意位置有3个及以上的点, 求这些点的最小外接凸多边形</p><h3 id="凸多边形定义"><a class="header-anchor" href="#凸多边形定义" aria-hidden="true">#</a> 凸多边形定义</h3><p>对于一个形状, 如果对于所有的穿过这个形状的线, 这条线只和这个形状至多相交两次. 如果多余两次, 这个形状就是一个非凸多边形或者说凹多边形</p><h3 id="多边形相交定义"><a class="header-anchor" href="#多边形相交定义" aria-hidden="true">#</a> 多边形相交定义</h3><ol><li>SAT - 分离轴理论 如果两个凸多边形(只支持凸多边形, 凹多边形需先分解为凸的)没有相交, 那么存在这两个物体在一个轴上的投影(比如三维物体经光照投射到平面上形成的影子, 同理, 二维图形投影成线)不重叠</li><li>GJK - Gilbert–Johnson–Keerthi 碰撞检测 如果两个形状(可以通过&quot;支持函数&quot;支持所有形状)重叠或者相交那么这两个形状的闵科夫斯基差(两个形状上所有点的差)产生的点的外围形状会包含原点。</li></ol><h2 id="演示"><a class="header-anchor" href="#演示" aria-hidden="true">#</a> 演示</h2><h2 id="方法介绍"><a class="header-anchor" href="#方法介绍" aria-hidden="true">#</a> 方法介绍</h2><h3 id="穷举法-o-n3"><a class="header-anchor" href="#穷举法-o-n3" aria-hidden="true">#</a> 穷举法 (O(n<sup>3</sup>))</h3><h3 id="分治法-快包-o-n㏒n"><a class="header-anchor" href="#分治法-快包-o-n㏒n" aria-hidden="true">#</a> 分治法 (快包 O(n㏒n))</h3><h3 id="jarvis-步进法-o-nh"><a class="header-anchor" href="#jarvis-步进法-o-nh" aria-hidden="true">#</a> Jarvis 步进法 (O(nH))</h3><h3 id="graham-扫描法-o-n㏒n"><a class="header-anchor" href="#graham-扫描法-o-n㏒n" aria-hidden="true">#</a> Graham 扫描法 (O(n㏒n))</h3><h3 id="melkman-算法-o-n"><a class="header-anchor" href="#melkman-算法-o-n" aria-hidden="true">#</a> Melkman 算法 (O(n))</h3><h2 id="melkman-算法实现"><a class="header-anchor" href="#melkman-算法实现" aria-hidden="true">#</a> Melkman 算法实现</h2><h2 id="升维"><a class="header-anchor" href="#升维" aria-hidden="true">#</a> 升维</h2><p>3D中的情况如何?</p>',16);h.render=function(l,r,h,i,t,d){return e(),a("div",null,[n])};export default h;export{r as __pageData};
